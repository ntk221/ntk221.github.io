---
title: "Modularity and Dependency"
date: 2023-01-15T23:05:43+09:00
draft: true
---

# はじめに
こんにちはー。今日は，**モジュラー性**と，**依存性**という概念について紹介します。

以前，[こちらの記事](https://ntk221.github.io/posts/separation_of_concerns/)で，ソフトウェアを構成するパーツのことをモジュールと呼ぶ，と言いました。ソフトウェアは，それぞれの仕事を行う複数のモジュールを適切に組み合わせることによって全体の機能を実現しているということです。

モジュラー性は，「システムのコンポーネントが分割，再結合されている度合いであり，柔軟性の高さ，用途の多さといった利点がある」と定義されます。

複数のモジュールから一つのソフトウェアを組み上げられた，モジュラー性の高いソフトウェアをつくるという設計指針にはいくつかのメリットがあるのですが，そのうちの一つのメリットはテストがしやすいという点にあります。...またテストかい，という感じでしょうかね。まぁ，そう言わずに...

しかし，モジュラーなソフトウェアに関するテストにおいては解決しなくてはならない問題点があります。それは依存性です。

# 依存性
ソフトウェアを複数のモジュールから構築しようとした時，モジュール同士には**依存関係**が生じます。

例えば，インタープリターというソフトウェアについて考えてみます。[こちらの資料](http://www.hpcs.cs.tsukuba.ac.jp/~msato/lecture-note/comp-lecture/note1.html)から引用しますと，インタープリターとは以下のようなモジュール群から構成されるソフトウェアです。

1. 字句解析(lexical analysis): 文字列を言語の要素（トークン、token）の列に分解する。
2. 構文解析(syntax analysis): token列を意味を反映した構造に変換。この構造は、しばしば、木構造で表現されるので、抽象構文木（abstract syntax tree）と呼ばれる。ここまでの言語を認識する部分を言語のparserと呼ぶ。
3. 意味解析(semantics analysis): 構文木の意味を解析する。インタプリターでは、ここで意味を解析し、それに対応した動作を行う。

これを図に表すと以下のようになります。
![](/images/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202023-01-16%2015.02.00.png)


ここで注目していただきたいのは，構文解析器が入力として受け取るトークン列は，字句解析器の出力になっているという点です。したがって,構文解析器は字句解析器なしでは仕事をすることができません。このことを，構文解析器は字句解析器に依存していると言います。

ソフトウェアの設計図においては，モジュール間の依存関係を矢印を用いて表現します。上に説明したことを図として表現すると以下のようになります。

![](/images/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202023-01-16%2015.02.44.png)

# 単体テスト
さて，ソフトウェアのテストにはさまざまな種類がありますが，モジュラーなソフトウェアにとって最も重要なテストは**単体テスト**であると言えます。

単体テストとは，以下の3つの性質を満たすテストとして定義されます。

- 単体(unit)と呼ばれる少量のコードを検証する
- 実行時間が短い
- 隔離された状態で実行される

3つ目の条件は抽象的に表現すると，モジュラー性が確保された状態でテストすることと表現できるのではないでしょうか。実はこの「隔離」の解釈で単体テストの２つの学派(古典学はとロンドン学派)が分かれるようです。まぁ，それはとりあえず置いといて...

# 事例
42Tokyoの課題で，push_swapというものがあります。この課題ではスタックというデータ構造を使って，整数のソートを行うソフトウェアをつくります。この課題で私は以下のようなディレクトリ構造でコードを管理していました。以下に示すのは単純化されたものです。

push_swap

```

./include/色々なヘッダファイル
./stack/スタックというデータ構造を定義するファイル群
./sort/スタックをソートするための関数群

その他色々なファイルたち...

```

さて，すでに説明したように，push_swapとはスタックをソートするという課題でした。これはつまり，**ソート用の関数群はスタックというデータ構造に依存している**，ということができます。

依存関係がある場合，`sort`フォルダの中にあるファイルのみでテストするということができません。なぜなら，ソート用の関数群は，スタックに依存しており，スタックを用意するためのソースコードを必要とするからです。よって，ソート用の関数群はそれだけで完全に隔離された状態ではテストできません。ソート用の関数群をテストするには何らかの仕方で，スタックに対して依存関係を持たせる必要があります。

ここで，[以前の記事](https://ntk221.github.io/posts/separation_of_concerns/)と同様に，依存性の注入という考え方を使うことができます。前回はテストコードとソースコードの間でヘッダーファイルのインクルードで依存関係を持たせるということをしましたが，今回はフォルダのレベルで同じことを実現したいと思います。できるかな？うーん，まぁ，できるでしょう！

次回に続きます...

### **参照資料**
- [単体テストの考え方/使い方](https://book.mynavi.jp/ec/products/detail/id=134252)
- [組み込みソフトウェア開発のための構造化プログラミング](https://www.shoeisha.co.jp/book/detail/9784798147611)
- [継続的デリバリーのソフトウェア工学](https://bookplus.nikkei.com/atcl/catalog/22/12/01/00531/)

- [筑波大学の言語処理系授業の講義資料](http://www.hpcs.cs.tsukuba.ac.jp/~msato/lecture-note/comp-lecture/note1.html)
