<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>knittaのブログ</title>
    <link>https://ntk221.github.io/</link>
    <description>Recent content on knittaのブログ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 15 Jan 2023 23:05:43 +0900</lastBuildDate><atom:link href="https://ntk221.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modularity and Dependency</title>
      <link>https://ntk221.github.io/posts/modularity/</link>
      <pubDate>Sun, 15 Jan 2023 23:05:43 +0900</pubDate>
      
      <guid>https://ntk221.github.io/posts/modularity/</guid>
      <description>はじめに こんにちはー。今日は，モジュラー性と，依存性という概念について紹介します。
以前，こちらの記事で，ソフトウェアを構成するパーツのことをモジュールと呼ぶ，と言いました。ソフトウェアは，それぞれの仕事を行う複数のモジュールを適切に組み合わせることによって全体の機能を実現しているということです。
モジュラー性は，「システムのコンポーネントが分割，再結合されている度合いであり，柔軟性の高さ，用途の多さといった利点がある」と定義されます。
複数のモジュールから一つのソフトウェアを組み上げられた，モジュラー性の高いソフトウェアをつくるという設計指針にはいくつかのメリットがあるのですが，そのうちの一つのメリットはテストがしやすいという点にあります。
&amp;hellip;またテストかい，という感じでしょうかね。まぁ，そう言わずに&amp;hellip;
しかし，モジュラーなソフトウェアに関するテストにおいては解決しなくてはならない問題点があります。それは依存性です。
依存性 ソフトウェアを複数のモジュールから構築しようとした時，モジュール同士には依存関係が生じます。
例えば，インタープリターというソフトウェアについて考えてみます。こちらの資料から引用しますと，インタープリターとは以下のようなモジュール群から構成されるソフトウェアです。
字句解析(lexical analysis): 文字列を言語の要素（トークン、token）の列に分解する。 構文解析(syntax analysis): token列を意味を反映した構造に変換。この構造は、しばしば、木構造で表現されるので、抽象構文木（abstract syntax tree）と呼ばれる。ここまでの言語を認識する部分を言語のparserと呼ぶ。 意味解析(semantics analysis): 構文木の意味を解析する。インタプリターでは、ここで意味を解析し、それに対応した動作を行う。 これを図に表すと以下のようになります。 ここで注目していただきたいのは，構文解析器が入力として受け取るトークン列は，字句解析器の出力になっているという点です。したがって,構文解析器は字句解析器なしでは仕事をすることができません。このことを，構文解析器は字句解析器に依存していると言います。
ソフトウェアの設計図においては，モジュール間の依存関係を矢印を用いて表現します。上に説明したことを図として表現すると以下のようになります。
単体テスト さて，ソフトウェアのテストにはさまざまな種類がありますが，モジュラーなソフトウェアにとって最も重要なテストは単体テストであると言えます。
単体テストとは，以下の3つの性質を満たすテストとして定義されます。
単体(unit)と呼ばれる少量のコードを検証する 実行時間が短い 隔離された状態で実行される 3つ目の条件は抽象的に表現すると，モジュラー性が確保された状態でテストすることと表現できるのではないでしょうか。実はこの「隔離」の解釈で単体テストの２つの学派(古典学はとロンドン学派)が分かれるようです。まぁ，それはとりあえず置いといて&amp;hellip;
事例 42Tokyoの課題で，push_swapというものがあります。この課題ではスタックというデータ構造を使って，整数のソートを行うソフトウェアをつくります。この課題で私は以下のようなディレクトリ構造でコードを管理していました。以下に示すのは単純化されたものです。
push_swap
./include/色々なヘッダファイル ./stack/スタックというデータ構造を定義するファイル群 ./sort/スタックをソートするための関数群 その他色々なファイルたち... さて，すでに説明したように，push_swapとはスタックをソートするという課題でした。これはつまり，ソート用の関数群はスタックというデータ構造に依存している，ということができます。
依存関係がある場合，sortフォルダの中にあるファイルのみでテストするということができません。なぜなら，ソート用の関数群は，スタックに依存しており，スタックを用意するためのソースコードを必要とするからです。よって，ソート用の関数群はそれだけで完全に隔離された状態ではテストできません。ソート用の関数群をテストするには何らかの仕方で，スタックに対して依存関係を持たせる必要があります。
ここで，以前の記事と同様に，依存性の注入という考え方を使うことができます。前回はテストコードとソースコードの間でヘッダーファイルのインクルードで依存関係を持たせるということをしましたが，今回はフォルダのレベルで同じことを実現したいと思います。できるかな？うーん，まぁ，できるでしょう！
次回に続きます&amp;hellip;
参照資料 単体テストの考え方/使い方
組み込みソフトウェア開発のための構造化プログラミング
継続的デリバリーのソフトウェア工学
筑波大学の言語処理系授業の講義資料</description>
    </item>
    
    <item>
      <title>Test automation</title>
      <link>https://ntk221.github.io/posts/test_automation/</link>
      <pubDate>Mon, 19 Dec 2022 19:23:28 +0900</pubDate>
      
      <guid>https://ntk221.github.io/posts/test_automation/</guid>
      <description>はじめに 前回，前々回とテストについて書いてきました。前回の最後では，Makefileを使ってテスト用のコマンドを作ることができました。
ところで，このmakeというコマンド，どこかで見覚えがないでしょうか&amp;hellip;
&amp;hellip;はい，実はこのブログを構築している静的サイトジェネレータのコマンドhugoに似ています。Hugoについては，こちらの記事を読んでいただけると嬉しいです。
それでですね，上の記事で説明したように，このサイトはGithub Actionsを使うことで，自動的にビルドされています。この仕組みによって，毎回わざわざhugoコマンドを手元で打ってビルドする必要がなくなったのでした。
では，同じことがC言語プログラムのテストについてもできるのではないでしょうか？
&amp;hellip;えー，できます！
準備 Github Actionsをテスト用の環境として使いたいので，まずはこれまで作ってきたディレクトリをGithub に push しましょう。前回までの成果物はこんな感じでした。
$&amp;gt; tree . ├── Makefile ├── README.md ├── include │ └── my_abs.h ├── src │ └── my_abs.c └── tests └── test.c このディレクトリをGithubにpushします。以下のような感じになりました。
YAMLファイル Github Actions を使うためには，どういうイベントが起きたら，どういうジョブをするかといったルールを記述するファイルが必要になります。このファイルはYAMLという形式で記述されている必要があります。
というわけで，YAMLファイルが必要になるのですが，便利なことに，基本的な形が整えられたファイルをGithub上でゲットすることができます。やった〜。
まずは，Actionsタブをクリックします。
すると，ページが遷移して，Suggested for this repositoryに，C/C++ with Make という設定が確認できます。
Configureというタブをクリックします。
おー！これが欲しかったのよ〜。
Start commit というタブをクリックして，このYAMLファイルをプロジェクトに追加しましょう。
そして，ローカルに変更を反映するために，git pullコマンドを打っておきましょう。リポジトリは以下のような構成になりました。
c-cpp.yml の編集 現在のc-cpp.ymlファイルには，configureというよくわからないフィールドが含まれているので，思い切って今回これは消しちゃうことにします。問題が起きたら，もう一度戻って考えることにしましょう。
また，makeにも現在のMakefileに記述されていないルールを使っているものがあるので，これらは削除して，代わりにmake testを追加します。jobの名前に関しては，今回走らせたい処理はビルドではなく，テストなので，ここも書き換えることにします。最終的に以下のようなYAMLファイルになりました。
name: C/C++ CI on: push: branches: [ &amp;#34;main&amp;#34; ] pull_request: branches: [ &amp;#34;main&amp;#34; ] jobs: test: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: test run: make test では，mainブランチにpushしてみましょう。Githubのページを覗いてみましょう。</description>
    </item>
    
    <item>
      <title>Separation of concerns</title>
      <link>https://ntk221.github.io/posts/separation_of_concerns/</link>
      <pubDate>Thu, 15 Dec 2022 11:51:01 +0900</pubDate>
      
      <guid>https://ntk221.github.io/posts/separation_of_concerns/</guid>
      <description>はじめに 前回の記事では，テストファーストのやり方で関数を開発するということをしました。結果として以下のようなコードが出来上がりました。
#include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;limits.h&amp;gt; int my_abs(int x) { if (INT_MIN) return (-1); if (x &amp;lt; 0) return (-x); else return (x); } void test(void) { bool result = (my_abs(-100) == 100) &amp;amp;&amp;amp; (my_abs(100) == 100); bool special = (my_abs(INT_MIN) == -1) &amp;amp;&amp;amp; \ (my_abs(INT_MAX) == INT_MAX) &amp;amp;&amp;amp; \ (my_abs(0) == 0); if (result) puts(&amp;#34;ok&amp;#34;); else puts(&amp;#34;ko&amp;#34;); } int main(void) { test(); } しかし,前回のコードにはちょっとした問題の芽が潜んでいます。それは，テストの対象となるコードと，テスト用のコードが同一のファイルに含まれているという点です。今のやり方でコードを管理していると，テスト対象となるコードが，テスト用のコードを呼び出すといった意図しない呼び出し関係が生じてしまうかもしれません。
関心ごとの分離 前回の記事に書いたように，ソフトウェアはそれぞれが固有の働きをする複数のパーツからなると考えることができます。この時非常に重要なのは，各パーツは一つの仕事を担当するように設計する，ということです。各パーツの仕事を明確にして管理しなければ，先ほど確認したようなコード間での意図しない結合が起きてしまったり,どのファイルにどの関数が含まれるのかわからなくなってしまうからです。このような設計指針で設計されたソフトウェアのパーツを単一責務であると言います。ところで，ソフトウェアのパーツのことは一般にモジュールと呼ばれるので，今後は我々もモジュールという言葉を使うことにしましょう。
テストと開発コードはそれぞれ異なる仕事をする関数です。従って，これらのコードを含むモジュールが単一責務を満たすようにするためには，これらは異なるモジュールに分離する必要があります。このように単一責務を満たすために，モジュールを管理しやすい単位に分割することを関心ごとの分離，と言います。今回はmy_abs()と，test()を違うファイルに分割すれば良いことになります。それぞれ，my_abs.c,test.cというファイルを作って分離しましょう。</description>
    </item>
    
    <item>
      <title>Test first</title>
      <link>https://ntk221.github.io/posts/test_first/</link>
      <pubDate>Tue, 06 Dec 2022 06:33:04 +0900</pubDate>
      
      <guid>https://ntk221.github.io/posts/test_first/</guid>
      <description>はじめに いろいろあって，かっこいいブログを作ることができたので，早速なんか書いていこうと思います。今回はテストについてです。
テストファースト ソフトウェア開発において，プログラマはソフトウェアの部品となるデータ構造や関数を一つづつ作っていくという作業をします。この時，関数やデータ構造にはそれぞれ期待される役割を持っています。例えば，int abs(int x)という関数は，絶対値を返すという機能を持っていることを期待されます。このような期待される役割を機能要件と呼ぶこともあります。
機能要件が定まっていたとしても，それだけでプログラムを書いていくのは難しいことが多いと思います。ソフトウェアの期待される機能を実現するには，それを複数の部品に分割していく必要もあるでしょう。このような作業はソフトウェアの設計に含まれます。
ソフトウェアの設計が終わって，分割された一つの関数を実装するという段階になってもまだどのように実装すればいいかわからないということがあります 。このような場合にはどうしたら良いでしょうか。
一つの方法として，まずテストを書くということから始めることができます。関数が果たすべき役割がある程度明確になっていれば，その関数が果たす仕事の典型的なケースについては列挙することができるはずだからです。これができないということは，関数の典型的な振る舞いさえも明らかではない，ということであり，もう一度設計の段階に戻って考えることになります。例えば，abs(x)で言うと以下のようなテストを書くことができます。
#include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int my_abs(int x); void test(void) { bool result = (my_abs(-100) == 100) // -100の絶対値は100と期待される if (result) puts(&amp;#34;ok&amp;#34;); else puts(&amp;#34;ko&amp;#34;); } int main(void) { test(); } では，このコードが書かれたファイルをtest.cという名前で保存して，コンパイルしてみましょう。結果は以下のようになります。
あらまぁ，コンパイルできてないみたいですね。なんででしょうか&amp;hellip;
はい，答えは簡単で，my_absという関数がまだないからですね。test.cにmy_absの実装を追加しましょう。こんな感じでしょうかね。
int my_abs(int x) { return(-x); } コンパイルして，実行してみます。
わーい，okだ！
okじゃない しかし，absの典型的な場合とは他にもあります。入力が正の整数の時には，absは，その数をそのまま返さなくてはなりません。この振る舞いについてもテストしましょう。
#include &amp;lt;stdbool.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int my_abs(int x) { return (-x); } void test(void) { bool result = (my_abs(-100) == 100) &amp;amp;&amp;amp; (my_abs(100) == 100); if (result) puts(&amp;#34;ok&amp;#34;); else puts(&amp;#34;ko&amp;#34;); } int main(void) { test(); } 結果は&amp;hellip;</description>
    </item>
    
    <item>
      <title>How to build your blog</title>
      <link>https://ntk221.github.io/posts/how_to_build_blog/</link>
      <pubDate>Wed, 30 Nov 2022 02:59:10 +0900</pubDate>
      
      <guid>https://ntk221.github.io/posts/how_to_build_blog/</guid>
      <description>こんにちは!42tokyo Advent Calendar 2022の14日目を担当する, knittaです。よろしくお願いします。
はじめに 突然ですが，皆さんこういうことを思ったことがないでしょうか。
「あー，なんか有無を言わさずみんなに褒められて，気分良くなりたいなぁ&amp;hellip;」
こんなときは，みんなと同じことをやっていてはいけない，ということで私は42Tokyo というところの入学試験(Piscine)を受けて見事合格しました。それから僕は友達を集めて，「ねぇみんな聞いてー！僕,42Tokyoに合格したよ〜〜〜」と言いました。すると，みんなこう言いました。
「なにそれ〜」
この様な結果から次の2点の事実が観察できます。一つは
「42Tokyo の知名度は低く，その価値は社会から認識されていない」 という点。 もう一つは，
「みんなと違うことをやったからと言って，それだけで誉められる訳ではない」 という点です。 今回のテーマ 以上の観察から私はこう思いました。
「42Tokyo の価値をみんなに知ってもらって，かつ，みんなに褒められた〜い」
そのためには， 42Tokyo がどの様な場所で，私がどの様な人間であるかを知ってもらうための情報を発信する方法が必要になると思います。また，なんかかっこいいやり方でそれを実現するのがよいのではないでしょうか。カッコいいほうが自慢できるし，誉められそうなので😄
静的サイトジェネレータ + Github Pages = cool 検索エンジンを駆使して情報を集めていった結果，
静的サイトジェネレータ
Github Pages
というものを使えば，カッコいいサイトを作って，Github で公開することができそうだぞ，ということがわかりました。これを使って42Tokyoのことや，私が今やっていることについて，coolに情報を発信することができるのではないかな？
では，早速やってみましょう！
&amp;hellip;
とその前に一応これらの用語について用語を整理しておきます。
静的サイトジェネレータ &amp;hellip; Markdown などの記法で書かれたテキストファイルから，静的なWebページを生成するソフトウェアである
Github Pages &amp;hellip; 静的サイトのホスティングサービスであり，これを使って静的サイトジェネレータを使って作った Webサイトを運用することができる。
実際にやってみる では，実際に静的サイトジェネレータを使って，Webサイトを作ってから，Github Pages にデプロイしてみましょう。今回私が使う静的サイトジェネレータは，Hugoというものです。
私の環境(M1 Mac)では，Homebrew というパッケージマネージャを使って，Hugo をシステムに導入することができました。
$&amp;gt; brew install hugo これだけで，Hugo を使って静的サイトを作ることができます。まずは，サイトの雛形を作りましょう。以下のようなコマンドを打って実行するだけでいい。
$&amp;gt; hugo new site &amp;lt;サイト名&amp;gt; &amp;lt;サイト名&amp;gt;で指定してディレクトリが新しくできるので，このディレクトリに移動して，tree コマンドを打ってみると以下の様な構成になっていることがわかリます。</description>
    </item>
    
  </channel>
</rss>
